---
title: 一切从加密说起
tag:
- crypto
- ssl/tsl
---

![加密](https://documents.trendmicro.com/images/TEx/articles/encryption1.jpg)

<!-- more -->

### [我们为什么需要加密](https://www.schneier.com/blog/archives/2015/06/why_we_encrypt.html)

*   ##### 加密可以保护我们的数据。无论数据是正存放在我们自己的计算机上，还是位于数据中心，或者正在通过互联网传送的途中，加密都可以提供防护。加密可以保护我们的聊天，不管是视频、语音还是文字。加密可以保护我们的隐私，可以隐藏我们的踪迹，甚至有时候，它会保护我们的性命。这种保护是攸关我们每个人的。
*   ### 加密是我们所拥有的最强力的隐私保护技术，是唯一适合避免大规模监视。
*   ### 避免犯罪分子撒网寻找可乘之机——的技术。
*   ### 通过使用加密迫使双方都只能专注于具体的个体目标，我们也保护了这个社会。

### 加密算法

*   #### 对称加密(加密者和解密者用的秘钥都是一样的)

    *   #### 常见的对称加密算法有 DES、3DES、AES、Blowfish、IDEA、RC5、RC6
    *   举个简单例子，我把我的数据块切分成 32 位大小的，然后都和我的秘钥 key(32 位)进行异或，在相加，这就是个简单的对称加密了。。。有了我的 key 就可以解开了，在异或一次我的 key 就解开了
    *   #### 举个例子 AES 的模式，有 128，256 bit 的，接下来是加密模式
        ECB：是一种基础的加密方式，密文被分割成分组长度相等的块（不足补齐），然后单独一个个加密，一个个输出组成密文。
        CBC：是一种循环模式，前一个分组的密文和当前分组的明文异或操作后再加密，这样做的目的是增强破解难度。
        CFB/OFB 实际上是一种反馈模式，目的也是增强破解的难度。还有填充方式，cbc 是需要填充的， cbc 还需要 iv, 初始化向量

    > ECB 和 CBC 的加密结果是不一样的，两者的模式不同，而且 CBC 会在第一个密码块运算时加入一个初始化向量。

*   #### 非对称加密(加密者和解密者使用的 key 是不同，就说加密者使用 key1 加密，解谜者使用 key2 解密)

    1.  非对称加密算法 RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用），有个公钥和私钥，公钥加密的数据只有对应的私钥能解开，而私钥加密的数据就只有公钥能解开了 ([rsa 原理](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)),被破解的难度在于大整数的因式分解困难, rsa 的加密明文是必须小于 key 的 [明文，密文长度](http://www.metsky.com/archives/657.html)而密文长度是和密钥长度是一致的。

    2.  安全性 ECDH > DHE > RSA,DH, 前两者提供前向安全: 前向安全: 用来产生会话密钥(session key)的长期密钥(long-term key)泄露出去，不会造成之前通讯时使用的会话密钥(session key)的泄露，也就不会暴漏以前的通讯内容。简单的说，当你丢了这个 long-term key 之后，你以后的行为的安全性无法保证，但是你之前的行为是保证安全的

    3.  rsa 加密时注意项, 跟 DES，AES 一样，RSA 也是一个块加密算法（ block cipher algorithm），总是在一个固定长度的块上进行操作。 当明文长度不够加密的长度时需要补足, 因为一次加密的长度是有固定的，为什么是固定的请看 rsa 原理篇


        RSA 加密常用的填充方式有下面 3 种：

        1.  RSA_PKCS1_PADDING 填充模式，最常用的模式，当你选择 RSA_PKCS1_PADDING 填充模式时，如果你的明文不够 128 字节， 加密的时候会在你的明文中随机填充一些数据，所以会导致对同样的明文每次加密后的结果都不一样。对加密后的密文，服务器使用相同的填充方式都能解密。解密后的明文也就是之前加密的明文。


        ```
        要求:
        输入：必须 比 RSA 钥模长(modulus) 短至少11个字节, 也就是　RSA_size(rsa) – 11
        如果输入的明文过长，必须切割，　然后填充

        输出：和modulus一样长

        根据这个要求，对于512bit的密钥，　block length = 512/8 – 11 = 53 字节
        ```

        2.  for RSA_NO_PADDING 　　不填充，当你在客户端选择 RSA_NO_PADDING 填充模式时，如果你的明文不够 128 字节， 加密的时候会在你的明文前面，前向的填充零。解密后的明文也会包括前面填充的零，这是服务器需要注意把解密后的字段前向填充的零去掉，才是真正之前加密的明文


          ```
          输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，　然后填充

          输出：和modulus一样长

          但跟AES等不同的是，　block length是跟key length有关的。

          每次RSA加密的明文的长度是受RSA填充模式限制的，但是RSA每次加密的块长度就是key length。
          ```

        3.  RSA_PKCS1_OAEP_PADDING，RSA_PKCS1_OAEP_PADDING 填充模式没有使用过， 他是 PKCS#1 推出的新的填充方式，安全性是最高的，和前面 RSA_PKCS1_PADDING 的区别就是加密前的编码方式不一样

          ```
          输入：RSA_size(rsa) – 41

          输出：和modulus一样长
          ```

        一句话不同的填充方式加解密也是不同的，使用的时候要注意

### ssl/tls 的加密流程

[详见](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)

### 数字证书

*   #### [数字证书和数字签名的原理](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)
    简单来说数字签名就是传输信息的摘要，数字证书就是 CA 用自己的私钥把你的公钥及其他信息加密后生成内容, 即 CA 用自己的私钥来给你的公钥做数字签名
*   #### 现在的数字证书一般采用证书的格式遵循 ITUT X.509 国际标准。一个标准的 X.509 数字证书包含以下一些内容

    1.  证书的版本信息;
    2.  证书的序列号，每个证书都有一个唯一的证书序列号;
    3.  证书所使用的签名算法;
    4.  证书的发行机构名称，命名规则一般采用 X.500 格式;
    5.  证书的有效期，现在通用的证书一般采用 UTC 时间格式，它的计时范围为 1950-2049;
    6.  证书所有人的名称，命名规则一般采用 X.500 格式;
    7.  证书所有人的公开密钥;
    8.  证书发行者对证书的签名。

    *   #### 证书格式

        *   ##### PEM 格式

            PEM 格式通常用于数字证书认证机构（Certificate Authorities，CA），扩展名为.pem, .crt, .cer, and .key。内容为 Base64 编码的 ASCII 码文件，有类似"-----BEGIN CERTIFICATE-----" 和 "-----END CERTIFICATE-----"的头尾标记。服务器认证证书，中级认证证书和私钥都可以储存为 PEM 格式（认证证书其实就是公钥）。Apache 和类似的服务器使用 PEM 格式证书。

        *   ##### DER 格式

            DER 格式与 PEM 不同之处在于其使用二进制而不是 Base64 编码的 ASCII。扩展名为.der，但也经常使用.cer 用作扩展名，所有类型的认证证书和私钥都可以存储为 DER 格式。Java 是其典型使用平台。

        *   ##### PKCS#7/P7B 格式

            PKCS#7 或 P7B 格式通常以 Base64 的格式存储，扩展名为.p7b 或 .p7c，有类似 BEGIN PKCS7-----" 和 "-----END PKCS7-----"的头尾标记。PKCS#7 或 P7B 只能存储认证证书或证书路径中的证书（就是存储认证证书链，本级，上级，到根级都存到一个文件中）。不能存储私钥，Windows 和 Tomcat 都支持这种格式。

        *   ##### PKCS#12/PFX 格式

            PKCS#12 或 PFX 格式是以加密的二进制形式存储服务器认证证书，中级认证证书和私钥。扩展名为.pfx 和 .p12，PXF 通常用于 Windows 中导入导出认证证书和私钥。

*   X.509 证书标准支持三种不对称加密算法：RSA, DSA, Diffie-Hellman algorithms。最常用的是 RSA 算法

*   数字签名的作用
    1.  是能确定消息的不可抵赖性，因为他人假冒不了发送方的私钥签名。发送方是用自己的私钥对信息进行加密的，只有使用发送方的公钥才能解密。
    2.  是数字签名能保障消息的完整性。一次数字签名采用一个特定的哈希函数，它对不同文件产生的数字摘要的值也是不相同的
*   数字证书的作用
    1.  不可抵赖性
    2.  消息的完整性
    3.  身份认证

### CA 数字证书认证机构（英语：Certificate Authority，缩写为 CA）

*   负责发放和管理数字证书的权威机构，承担公钥体系中公钥的合法性检验的责任。
*   CA 是证书的签发机构，它是 PKI 的核心。CA 是负责签发证书、认证证书、管理已颁发证书的机关。它要制定政策和具体步骤来验证、识别用户身份，并对用户证书进行签名，以确保证书持有者的身份和公钥的拥有权。
*   CA 也拥有一个证书（内含公钥）和私钥。网上的公众用户通过验证 CA 的签字从而信任 CA ，任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书。
*   如果用户想得到一份属于自己的证书，他应先向 CA 提出申请。在 CA 判明申请者的身份后，便为他分配一个公钥，并且 CA 将该公钥与申请者的身份信息绑在一起，并为之签字后，便形成证书发给申请者。
*   如果一个用户想鉴别另一个证书的真伪，他就用 CA 的公钥对那个证书上的签字进行验证，一旦验证通过，该证书就被认为是有效的

### 公钥基础设施（Public Key Infrastructure，简称 PKI）

[wiki](https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD)

参考:

1.  [tsl/ssl 进阶](https://segmentfault.com/a/1190000007283514)
2.  [ecdh, dh](http://www.cnblogs.com/fishou/p/4206451.html)
3.  [pki 体系](http://blog.csdn.net/hherima/article/details/52469488)
4.  [ca 证书链](http://www.jianshu.com/p/46e48bc517d0)
