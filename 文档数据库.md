http://blog.nosqlfan.com/html/4156.html

### 总结一下
* 多对多关系表的存在，最好是不要存在关系表
* 多对一与一对多，关系模型只有多对一（因为关系模型要保证字段的不可分解性第一范式吧），而关系数据库是可以存在一对多的。例如

  | comment_id | user_id | content |
  | :------| ------: | :------: |
  | 0 | 0 | NoSQL反模式是好文章 |
  | 1 | 0 | 是啊 |
  上述表格就是一个多对一的表格

  | user_id | user_name | comment_id[] |
  | :------| ------: | :------: |
  | 0 | Jake | 0,1 |
  | 1 | Rose | 1,2 |
  而这个表格就是个典型的一堆多的表格。
  其实这两种的无论是哪个都是可以的具体要看是根据什么来查询，以及要查询什么信息，假设要查询用户以及comment信息

    * 比如根据user_id来查询，使用一对多就合适，反而使用comment_id来查询就不好了，因为我们根据comment_id来查询comment ok, 但是要去查询用户信息就得多一个索引来根据comment_id去一对多的表里去查询用户信息。
    * 反之同理
* 内联数据的滥用
  * 频繁查询一些内联字段，丢弃其他字段，就是说只要内联数据，所以就得建立索引，从而导致索引泛滥，这种的就用引用来替代
  * 内联数据膨胀，我们知道文档数据库一般都会对单一文档有大小限制，这种的就是限制最大大小
  * DBA对内联字段无法单独维护，因为数据库的权限都是给到collection的，并且切表难，备份难s
  * 集成其他工具难，接入新应用难，这种情况就得使用关系数据的范式了，使用引用来替代了。说白了，内联内容就是把数据和应用绑死了，就真的应了mongodb所说的尽量让数据内容和应用保持一致，突然发现，mongodb应当用来做缓存，底层再来一个更细致的数据划分存储比如mysql，将数据划分为更新的粒度
  * 在线计算，长时间的计算比如查询和聚合运算。最好使用第三方工具吧。如Hadoop, Storm
  * 不合理的ID, 一个long的id才8个字节，而一个20个utf8的字符串大约会占用60个字节，快10倍的大小差距。